"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const t=Symbol("Patcher"),e=Symbol("WatcherProxy"),r=Symbol("TargetRef"),s=t=>{const e=new Map;for(let r=0;r<t.length;r+=1){const s=t[r];if(!e.has(s))for(let r=0;r<t.length;r+=1){const o=t[r];s===o||e.has(o)||o.path.includes(s.path)&&a(s,o)&&e.set(o,!0)}}return t.filter(t=>!e.has(t))},a=(t,e)=>{const r=t.path;if(!e.path.includes(r))return!1;switch(t.op){case"remove":return!0;case"add":return o(t,e),!0;case"replace":return!0;default:return!1}},o=(t,e)=>{const r=t.value,s=e.path.replace(t.path,""),a=s.split("/").filter(t=>!!t);n({...e,path:s,pathArray:a},r)},n=(e,r)=>{const{op:s,pathArray:a,value:o}=e,n=a.length;if(!n)return;let i,l=r,h=l.hasOwnProperty(t)?{entity:l,pathArray:[...a]}:null;for(let e=0;e<n-1;e+=1){if(i=a[e],!l.hasOwnProperty(i))throw new Error(`applyJSONPatchOperation cannot walk json patch path ${a.join("/")}. Cannot access path ${[...a].slice(0,e).join("/")}.`);l=l[i],l.hasOwnProperty(t)&&(h={entity:l,pathArray:[...a].slice(e+1)})}const c=a[n-1];if(h&&"applyPatch"in h.entity&&"function"==typeof h.entity.applyPatch){const t=e.pathArray.filter(t=>-1!==(null==h?void 0:h.pathArray.indexOf(t))),r=t.join("/");h.entity.applyPatch({...e,path:r,pathArray:t})}else switch(s){case"add":case"replace":Object.assign(l,{[c]:o});break;case"remove":delete l[c]}};class i{constructor(){this.mutationMaps=new Map,this.mutationDirtyPaths=new Map,this.getSubProxy=(t,e,r)=>{const s=this.mutationMaps.get(t);let a=null==s?void 0:s.get(e);return a||(a=new Proxy(e,new c({target:e,dirtyPaths:this.mutationDirtyPaths.get(t),pathArray:r,proxyfyAccess:(e,r)=>this.getSubProxy(t,e,r)})),null==s||s.set(e,a)),a}}startMutation(t){var e;this.mutationMaps.set(t,new WeakMap),this.mutationDirtyPaths.set(t,new Set);const r=new Proxy(t,new c({target:t,dirtyPaths:this.mutationDirtyPaths.get(t),proxyfyAccess:(e,r)=>this.getSubProxy(t,e,r)}));null===(e=this.mutationMaps.get(t))||void 0===e||e.set(t,r)}hasRoot(t){return this.mutationMaps.has(t)}commit(t){const e=this.mutationDirtyPaths.get(t);if(!e)return[];const r=Array.from(e).reduce((t,e)=>{const{pathArray:r,ops:s}=e,a=r.length?"/"+r.join("/"):"";for(let e=0;e<s.length;e+=1){const o=s[e],{old:n,value:i}=o;n!==i&&t.push({...o,path:`${a}/${o.path}`,pathArray:[...r,o.path]})}return t},[]),a=s(r);return y.processPatches(t,a),this.mutationMaps.delete(t),this.mutationDirtyPaths.delete(t),a}mutate(t,e){var r;const s=!this.hasRoot(t);s&&this.startMutation(t);const a=null===(r=this.mutationMaps.get(t))||void 0===r?void 0:r.get(t);if(a)return e(a),s?this.commit(t):[]}}const l=new i,h=(t,e)=>l.mutate(t,e);class c{constructor(t){this.deleted={},this.original={},this.ops=[];const{target:e,pathArray:r=[],proxyfyAccess:s,dirtyPaths:a}=t;this.pathArray=r,this.targetRef=e,this.proxyfyAccess=s,this.dirtyPaths=a}get(t,s){if("symbol"==typeof s&&s===r)return this.targetRef;if("symbol"==typeof s&&s===e)return!0;if("symbol"==typeof s||"hasOwnProperty"===s)return Reflect.get(t,s);if("string"==typeof s&&this.deleted.hasOwnProperty(s))return;const a=t[s];return"object"==typeof a&&null!==a?this.proxyfyAccess(a,[...this.pathArray,s]):a}set(t,s,a){this.dirtyPaths.add(this);let o="add";t[s]&&(o=a?"replace":"remove"),!this.original.hasOwnProperty(s)&&t.hasOwnProperty(s)&&(this.original[s]=t[s]);let n=a;if("object"==typeof a&&null!==a){const t=a;n=t.hasOwnProperty(e)?t[r]:{...a}}let i=this.original[s];return"object"==typeof i&&null!==i&&(i={...i}),this.ops.push({op:o,path:""+s,old:i,value:n}),Reflect.set(t,s,a)}deleteProperty(t,e){if(e in t&&"string"==typeof e){this.dirtyPaths.add(this),this.deleted[e]=!0,this.original.hasOwnProperty(e)||(this.original[e]=t[e]);let r=this.original[e];"object"==typeof r&&null!==r&&(r={...r}),this.ops.push({op:"remove",path:""+e,old:r,value:void 0})}return Reflect.deleteProperty(t,e)}getOwnPropertyDescriptor(t,r){if("string"!=typeof r||!this.deleted[r])return r===e?{configurable:!0,value:!0}:Reflect.getOwnPropertyDescriptor(t,r)}ownKeys(t){return Reflect.ownKeys(t)}has(t,e){return Reflect.has(t,e)}}const p=(t,e)=>{if(-1===t.indexOf("**")&&t.length!==e.length)return!1;for(let r=0;r<t.length;r+=1)if(t[r]!==e[r]&&("*"!==t[r]||!e[r])){if(r+1===t.length&&"**"===t[r]&&e[r])return!0;if(e[r]!==t[r])return!1}return!0};class u{constructor(t,e,r){this.lastSelectorValue=null,this.callbackSet=new Set,this.mappingFn=e,this.disposeMethod=r,this.selectorSet=t.map(t=>t.startsWith("/")?t.substr(1).split("/"):t.split("/"))}reshape(t){this.selectorSet=t(this.selectorSet)}match(t){return((t,e)=>{for(let r=0;r<t.length;r+=1)for(let s=0;s<e.length;s+=1)if(p(t[r],e[s]))return e[s];return!1})(this.selectorSet,t)}run(t,e){const r=this.mappingFn(t,e);this.lastSelectorValue!==r&&(this.lastSelectorValue=r,this.callbackSet.forEach(t=>{t(r)}))}observe(t){if(this.callbackSet.has(t))throw new Error("this callback was already registered. If you run things twice, create two different callbacks");return this.callbackSet.add(t),()=>{this.callbackSet.delete(t)}}dispose(){this.disposeMethod()}}const y=new class{constructor(){this.selectorMap=new WeakMap}registerSelector(t,e){let r=this.selectorMap.get(t);r||(r={selectors:[]},this.selectorMap.set(t,r)),r.selectors.push(e)}removeSelector(t,e){const r=this.selectorMap.get(t);if(!r)return;const s=r.selectors.indexOf(e);-1!==s&&(r.selectors=[...r.selectors.slice(0,s),...r.selectors.slice(s+1)])}processPatches(t,e){const r=this.selectorMap.get(t);if(!r||!r.selectors||0===r.selectors.length)return;const s=e.map(t=>t.pathArray);for(let a=0;a<r.selectors.length;a+=1){const o=r.selectors[a];o.match(s)&&o.run(t,e)}}};exports.IObservableDomain=class{},exports.MutationsManager=i,exports.Patcher=t,exports.ProxyMutationObjectHandler=c,exports.applyInternalMutation=(t,e)=>{t.forEach(t=>{n(t,e)})},exports.applyJSONPatchOperation=n,exports.combinedJSONPatches=s,exports.inversePatch=t=>{const{path:e,pathArray:r,op:s,value:a,old:o}=t;switch(s){case"add":return{op:"remove",value:o,old:a,pathArray:r,path:e};case"remove":return{op:"add",value:o,old:a,pathArray:r,path:e};case"replace":return{op:"replace",value:o,old:a,pathArray:r,path:e}}},exports.mutate=h,exports.mutateFromPatches=(t,e)=>{h(t,t=>{for(let r=0;r<e.length;r+=1)n(e[r],t)})},exports.pathMatchesSource=p,exports.select=(t,e,r)=>{const s=y,a=new u(e,r,()=>{s.removeSelector(t,a)});return s.registerSelector(t,a),a};
